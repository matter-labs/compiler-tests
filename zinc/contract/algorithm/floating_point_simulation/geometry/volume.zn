//! { "cases": [ {
//!     "name": "cube1",
//!     "input": [
//!         {
//!             "entry": "cube1",
//!             "calldata": [
//!             ]
//!         }
//!     ],
//!     "expected": [
//!         "27"
//!     ]
//! }, {
//!     "name": "cube2",
//!     "input": [
//!         {
//!             "entry": "cube2",
//!             "calldata": [
//!             ]
//!         }
//!     ],
//!     "expected": [
//!         "30422169911604024"
//!     ]
//! }, {
//!     "name": "sphere1",
//!     "input": [
//!         {
//!             "entry": "sphere1",
//!             "calldata": [
//!             ]
//!         }
//!     ],
//!     "expected": [
//!         "143675"
//!     ]
//! }, {
//!     "name": "sphere2",
//!     "input": [
//!         {
//!             "entry": "sphere2",
//!             "calldata": [
//!             ]
//!         }
//!     ],
//!     "expected": [
//!         "151504289520102405"
//!     ]
//! } ] }

const EPS: u128 = 1E6;
// PI * EPS^3
const PI: u128 = 3141592653589793238;
const PRECISION: u128 = 100;

struct Cube {
    a: u128,
}

struct Sphere {
    r: u128,
}

impl Cube {
    fn volume(self) -> u128 {
        self.a * self.a * self.a
    }
}

impl Sphere {
    fn volume(self, pi: u128) -> u128 {
        4 * pi * self.r * self.r * self.r / 3
    }
}

contract Test {
    pub fn cube1(self) -> u64 {
        let a = 3 as u128;
        let cube = Cube {a: a};
        cube.volume() as u64
    }

    pub fn cube2(self) -> u64 {
        let a = 312174 as u128;
        let cube = Cube {a: a};
        cube.volume() as u64
    }

    pub fn sphere1(self) -> u64{
        let r = 7 as u128;
        let sphere = Sphere {r: r};
        // volume * PRECISION
        (sphere.volume(PI) * PRECISION / EPS / EPS / EPS) as u64
    }

    pub fn sphere2(self) -> u64{
        let r = 71249 as u128;
        let sphere = Sphere {r: r};
        // volume * PRECISION
        (sphere.volume(PI) * PRECISION / EPS / EPS / EPS) as u64
    }
}