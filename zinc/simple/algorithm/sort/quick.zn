//! { "cases": [ {
//!     "entry": "ascending",
//!     "expected": 1
//! }, {
//!     "entry": "descending",
//!     "expected": 1
//! } ] }

const ARRAY_SIZE: u8 = 10;

enum Direction {
    Ascending = 0,
    Descending = 1,
}

fn ascending() -> u64 {
    let input = [7, 2, 1, 8, 10, 3, 5, 4, 9, 6];
    let output = quick_sort(input, 0, ARRAY_SIZE, Direction::Ascending);

    let is_one_first = output[0] == 1;
    let is_ten_last = output[ARRAY_SIZE - 1] == 10;
    let result = is_one_first && is_ten_last;
    if result { 1 } else { 0 }
}


fn descending() -> u64 {
    let input = [7, 2, 1, 8, 10, 3, 5, 4, 9, 6];
    let output = quick_sort(input, 0, ARRAY_SIZE, Direction::Descending);

    let is_ten_first = output[0] == 10;
    let is_one_last = output[ARRAY_SIZE - 1] == 1;
    let result = is_ten_first && is_one_last;
    if result { 1 } else { 0 }
}

// It copies all array for each call, so complexity O(n^2)
fn quick_sort(mut array: [u8; ARRAY_SIZE], begin: u8, end: u8, direction: Direction) -> [u8; ARRAY_SIZE] {
    if end - begin < 2 {
        return array;
    }
    let pivot = array[end-1];
    let mut i = begin - 1;

    for j in begin..end - 1 {
        if match direction {
            Direction::Ascending => array[j] < pivot,
            Direction::Descending => array[j] > pivot,
        } {
            i += 1;
            let temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
    array[end-1] = array[i+1];
    array[i+1] = pivot;

    array = quick_sort(array, begin, i+1, direction);
    array = quick_sort(array, i+2, end, direction);
    array
}
