//! { "cases": [ {
//!     "entry": "no_solution",
//!     "expected": 1
//! }, {
//!     "entry": "first",
//!     "expected": 1
//! }, {
//!     "entry": "second",
//!     "expected": 1
//! } ] }

const EPS: u128 = 1E10;
const PRECISION: u128 = 100;

fn no_solution() -> u64 {
    let a = 1 as u128;
    let mb = 1 as u128; // b = -1
    let c = 1 as u128;
    let p = main(a, mb, c);
    if !p.0 { 1 } else { 0 }
}

fn first() -> u64 {
    let mut a = 2 as u128;
    let mut mb = 7 as u128; // b = -7
    let mut c = 4 as u128;
    let p = main(a, mb, c);
    // check roots * PRECISION
    let result = p.0 &&
        p.1 * PRECISION / EPS == 278 &&
        p.2 * PRECISION / EPS == 71;
    if result { 1 } else { 0 }
}

fn second() -> u64 {
    let mut a = 17 as u128;
    let mut mb = 29 as u128; // b = -29
    let mut c = 12 as u128;
    let p = main(a, mb, c);
    // check roots * PRECISION
    let result = p.0 &&
        p.1 * PRECISION / EPS == 100 &&
        p.2 * PRECISION / EPS == 70;
    if result { 1 } else { 0 }
}

fn sqrt(n: u128) -> u128 {
    // binary search
    let mut l = 0 as u128;
    let mut r = n as u128;
    while l < r {
        let m = (l + r + 1) / 2;
        if m*m <= n {
            l = m;
        } else {
            r = m - 1;
        }
    }
    if n - l*l < (l+1)*(l+1) - n
        {l} else {l+1}
}

// mb = -b
// returns roots * EPS
fn main(a: u128, mb: u128, c: u128) -> (bool, u128, u128) {
    if mb*mb < 4*a*c {
        return (false, 0 as u128, 0 as u128);
    }
    let d = (mb*mb - 4*a*c)*EPS*EPS;
    let sd = sqrt(d);
    // hack, as -b not working
    let x1 = (mb*EPS + sd) / 2 / a;
    let x2 = (mb*EPS - sd) / 2 / a;
    (true, x1, x2)
}